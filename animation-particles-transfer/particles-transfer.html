<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particles Simulation</title>
    <link rel="stylesheet" href="../commons/css/buttons.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('https://images.unsplash.com/photo-1519681393784-d120267933ba');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            font-family: 'Roboto', sans-serif;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="scene"></canvas>

    <script>
        const canvas = document.getElementById('scene');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        const PARTICLES_NUMBER = 100;
        const PARTICLE_RADIUS = 5;
        const PARTICLE_SPEED = 2;
        
        // Setup canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Particle class
        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * PARTICLE_SPEED;
                this.vy = Math.sin(angle) * PARTICLE_SPEED;
                this.radius = PARTICLE_RADIUS;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                // Wall collisions
                if (this.x < this.radius) this.vx = Math.abs(this.vx);
                if (this.x > canvas.width - this.radius) this.vx = -Math.abs(this.vx);
                if (this.y < this.radius) this.vy = Math.abs(this.vy);
                if (this.y > canvas.height - this.radius) this.vy = -Math.abs(this.vy);
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fill();
            }
        }

        // Create particles
        const particles = Array.from({ length: PARTICLES_NUMBER }, () => new Particle());

        // Collision detection
        function checkCollisions() {
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < p1.radius + p2.radius) {
                        // Elastic collision resolution
                        const angle = Math.atan2(dy, dx);
                        const m1 = 1; // mass (same for all particles)
                        const m2 = 1;
                        
                        // Rotate velocity vectors
                        const u1 = rotate(p1.vx, p1.vy, angle);
                        const u2 = rotate(p2.vx, p2.vy, angle);
                        
                        // Swap tangential velocities (elastic collision)
                        const v1 = [u2[0], u1[1]];
                        const v2 = [u1[0], u2[1]];
                        
                        // Rotate back
                        const [v1x, v1y] = rotate(v1[0], v1[1], -angle);
                        const [v2x, v2y] = rotate(v2[0], v2[1], -angle);
                        
                        // Update velocities
                        p1.vx = v1x;
                        p1.vy = v1y;
                        p2.vx = v2x;
                        p2.vy = v2y;
                        
                        // Prevent overlap
                        const overlap = (p1.radius + p2.radius - distance) / 2;
                        p1.x -= overlap * (dx / distance);
                        p1.y -= overlap * (dy / distance);
                        p2.x += overlap * (dx / distance);
                        p2.y += overlap * (dy / distance);
                    }
                }
            }
        }

        function rotate(vx, vy, angle) {
            return [
                vx * Math.cos(angle) - vy * Math.sin(angle),
                vx * Math.sin(angle) + vy * Math.cos(angle)
            ];
        }

        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            checkCollisions();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
